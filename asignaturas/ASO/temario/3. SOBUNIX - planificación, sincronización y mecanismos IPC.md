## 3.1. Introducción
## 3.2. Planificación de procesos multihilos en SOBUNIX
### 3.2.1. Características generales
- Planificador: 
	- parte del núcleo encargada de decidir qué unidades planificables pasan a ser ejecutadas en los procesadores. 
	- Se encarga también de realizar los cambios de contexto
	- Gestiona las estructuras de datos necesarias para la implementación de la planificación: colas de prioridad
- Unidad planificable: si el SOBUNIX soporta hilos del núcleo serán estos, si no, los procesos
- Prioridad: 
	- número entre 0 y P_max asociado a cada unidad planificable. 
	- Dependiendo del SOBUNIX serán más prioritarios los de valor más alto, o viceversa. El planificador siempre intenta que se ejecute la unidad de mayor prioridad, salvo que no sea posible en caso de nucleos no expropiables
- Valor de la prioridad
	- se establece según varios criterios
		- modo de ejecución (usuario, núcleo)
		- tipo de trabajo
		- tiempo de procesador consumido
		- tiempo de espera en las colas
	- puede variar o no en el tiempo
		- estático
		- dinámico
- Colas de prioridad
	- planificación lo cal para cada cola
- Algunos SOBUNIX establecen clases de planificación por cada tipo de trabajo soportado
	- Funciones no dependientes de la clase
		- cambio de contexto
		- manipulación de colas
	- Funciones dependientes de la clase
- Existen llamadas al sistema para modificar el valor de la prioridad, con ciertas restricciones, o para cambiar la clase de planificación
### 3.2.2. Dos ejemplos ilustrativos de la planificación en SOBUNIX
- BSD 3.4
- Solaris
### 3.2.3. Expropiación del procesador
## 3.3. Mecanismos de sincronización del núcleo en SOBUNIX
### 3.3.1. Cerrojos
### 3.3.2. Semáforos
## 3.4. Dormir/despertar y colas de hilos dormidos en SOBUNIX
## 3.5. Mecanismos de comunicación entre procesos en SOBUNIX
### 3.5.1. Mecanismos IPC del System V
- Tipos
	- Semáforos
	- Colas de mensajes
	- Memoria compartida
- Tabla por cada tipo
	- Identificador numérico entero
	- Creador del recurso
	- Propietario del recurso
	- Permisos del recurso
	- Clave del recurso
	- Información propia de cada tipo de recurso
#### Semáforos
- Conjuntos de semáforos
- semid
- Tabla de conjuntos de semáforos existentes
	- Cada entrada sobre un conjunto
		- Creador
		- Propietario
		- Llave
		- Permisos de acceso
		- Puntero al array de los semáforos del conjunto
		- Nº de semáforos del conjunto
- Para cada semáforo se mantiene 
	- Una estructura con:
		- Valor actual (entero >= 0)
		- Nº de procesos esperando a que valga 0
		- Nº de procesos esperando a que se incremente
		- PID del proceso que hizo la última operación
	- Cola con los procesos dormidos en el semáforo
- Llamadas al sistema
	- semid = semget(llave, N, ind)
		- Crea un conjunto de semáforos u obtiene uno creado
	- r = semop(semid, oper, M)
		- Realiza operaciones sobre los semáforos de un conjunto
		- oper: array de estructuras sembuf, M: nº de estructuras sembuf
		- sembuf
			- identificador j
			- tipo de operación sem_op
				- nº entero
				- > 0 -> se suma al valor del semáforo
				- < 0 -> se comprueba si el valor del semáforo >= abs(sem_op)
					- Sí -> se resta
					- No -> se duerme el proceso hasta que se cumpla la condición
				- 0 -> se comprueba si el valor = 0
					- Sí -> no se realiza nada
					- No -> se duerme el proceso hasta que se cumpla la condición
			- indicadores
				- IPC_NOWAIT: no bloquear proceso si no se puede hacer la op.; devolver error
				- SEM_UNDO: deshacer la operación cuando el proceso termine
		- Cada operación se realiza de forma atómica, hasta que no empiece una no se puede hacer la siguiente
		- ok -> devuelve 0; ko -> devuelve 1
	- r = semctl(semid, j, orden, arg)
		- Lee y configura datos de control sobre un determinado conjunto de semáforos o sobre un semáforo de éste
		- orden: constante simbólica, especifica la operación a realizar
			- IPC_RMID: elimina un conjunto de semáforos
			- SETALL: establece el valor de todos los semáforos al valor indicado en arg
			- GETALL: obtiene el valor de todos los semáforos y lo guarda en arg
			- SETVAL: establece el valor del semáforo j (valor provisto en arg)
			- GETVAL: obtiene el valor del semáforo j y lo devuelve a r
		- ok: 0 o valor devuelto según la orden; ko: -1
		- arg argumentos requeridos por la operación
#### Colas de mensajes
- Buzones que posibilitan comunicación indirecta entre procesos
- FIFO
- Contenido de un mensaje
	- Tipo del mensaje
	- Cuerpo del mensaje
- Tabla de colas de mensajes
	- msgqid
- Llamadas al sistema
	- msgget
	- msgsnd
	- msgrcv
	- msgctl
#### Memoria compartida
- Región de memoria que puede ser leída o escrita por varios procesos
- shmid
- Llamadas al sistema
	- shmget
	- shmat
	- shmdt
	- shmctl
#### Ventajas e inconvenientes de los mecanismos IPC del System V
- Semáforos
	- Se pueden usar para garantizar la exclusión mutua en el uso de un recurso entre distintos procesos
	- Inconveniente: si no se usan adecuadamente pueden conducir a condiciones de carrera o interbloqueos. En programas extensos es fácil incurrir en este error
- Colas de mensajes
	- Se pueden usar para los mismos fines que los semáforos, además de para transmitir pequeñas cantidades de información entre procesos. 
	- Inconvenientes: 
		- La transmisión de información requiere de dos copias en memoria, una en el proceso de origen y otra en la cola, que se elimina cuando se copia al de destino
		- No es posible enviar mensajes a múltiples procesos, ya que, aunque se haga de forma que distintos procesos puedan recibir un mensaje (por el tipo), cuando el primero en acceder lo recupera el mensaje se elimina de la cola, impidiendo que el siguiente pueda leerlo
- Memoria compartida
	- Se pueden usar para el intercambio de pequeñas o grandes cantidades de información
	- Inconveniente: para evitar condiciones de carrera es necesario usar algún mecanismo de sincronización, basado en semáforos o en paso de mensajes
- Otros problemas comunes a los tres mecanismos
	- Una vez creado un recurso IPC, este perdura aún cuando los procesos que lo usen hayan terminado. Esto puede ser útil en determinados escenarios, pero también incurrir en usos inadecuados de memoria. Es responsabilidad del programador establecer los mecanismos necesarios para eliminar el recurso cuando deje de ser necesario.
	- Dado que los procesos que usen un mismo recurso pueden pertenecer a distintos usuarios, los permisos de éstos no suelen ser muy restrictivos, lo cual puede abrir la puerta a fallas de seguridad 
### 3.5.2. Otros mecanismos IPC 
- Señales
- Tuberías