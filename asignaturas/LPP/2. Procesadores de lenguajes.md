e## 2.2 Tipos de procesadores de lenguajes
### 2.2.1 Traductores
### 2.2.2 Ensambladores
### 2.2.3 Compiladores
- Etapas
	- Análisis
		- Léxico
		- Sintáctico
		- Semántico
	- Síntesis
		- Generación de código intermedio
		- Optimización
		- Generación de código objeto
- Clasificación
	- Según tipo de código máquina que generan
		- Código máquina puro
		- Código máquina aumentado
		- Código máquina virtual
	- Según el proceso de compilación
		- Compilador cruzado
		- Compilador con montador
		- Compilador en una o varias pasadas
		- Compilador incremental
		- Autocompilador
		- Metacompilador
- Momento en el procesado
	- Tiempo de compilación
	- Tiempo de ejecución
- Enlazadores
	- Montador de enlaces
	- Enlaza codigo objeto con librerias propias del sistema operativo para su ejecución
- Cargadores
	- Carga un programa en memoria
### 2.2.4 Intérpretes
### 2.2.5 Máquinas virtuales
### 2.2.6 Otros tipos
#### Decompiladores
#### Desensambladores
#### Depuradores
#### Analizadores de rendimiento
#### Optimizadores de código
#### Preprocesadores
#### Editores de lenguajes de programación
## 2.3 Estructura de un compilador
- Fases
	- Análisis (front-end)
		- Análisis léxico
		- Análisis sintáctico
		- Análisis semántico
	- Síntesis (back-end)
		- Generación de código intermedio
		- Optimización
		- Generación de código objeto
- Forma alternativa de estructurar en front-end y back-end 
	- Desacoplamiento respecto a una máquina concreta de la fase de análisis y generación de código intermedio
	- Front-end
		- Análisis léxico
		- Análisis sintáctico
		- Análisis semántico
		- Generación de código intermedio
	- Back-end
		- Optimización
		- Generación de código objeto
### 2.3.1 Análisis léxico
- Conceptos
	- Lexema
	- Patrón
	- Token
- Proceso
	- Se lee la secuencia de símbolos que forman la fuente de derecha a izquierda y se genera la secuencia de tokens encontrados
	- Se relacionan los errores que se puedan dar
	- Se introducen los identificadores encontrados en la tabla de símbolos, que será necesaria en fases posteriores de la compilación
- La identificación de tokens se realiza mediante gramáticas y lenguajes regulares
#### Alfabetos y cadenas
- Alfabeto o vocabulario -> conjunto finito de símbolos
- Cadena -> secuencia finita de símbolos de un determinado alfabeto
- El conjunto de todas las cadenas que se pueden formar con un alfabeto se denomina universo del discurso. Se representa W(V)
#### Gramáticas regulares
- Gramática formal -> conjunto de reglas que permiten generar cadenas de un alfabeto determinado
- Gramática regular 
	- Definida por G(T,N,S,P)
		- T -> vocabulario terminal (constantes)
		- N -> vocabulario no terminal (variables)
		- S -> símbolo inicial
		- P -> conjunto de producciones
	- Todas las cadenas están formadas por los símbolos de T
	- N: elementos auxiliares para la definición de producciones
	- S símbolo no terminal dede el que se comienza la derivación
	- P transformaciones de cadenas fromadas por símbolos de N y T en otras. Se expresan mediante antecedentes y consecuentes separados por flecha
#### Lenguajes regulares
- Conjunto de las cadenas formadas por los símbolos de un alfabeto que se pueden generar a partir de las reglas de una gramática.
- Un lenguaje regular es aquél definido a partir de una gramática regular.
- Se puede definir a partir de 
	- expresiones regulares
		- Operadores:
			- | -> unón
			- . -> concatenación
			- \* -> cierre de Kleene
		- Cuantificadores
			- + -> una o más veces
			- ? -> 0 o 1 vez
		- Uso de paréntesis para indicar precedencia
		- Precedencia de operadores -> \* . |
		- Propiedades
			- Unión conmutativa
			- Concatenación asociativa
			- Concatenación distributiva por la derecha sobre la unión
			- Concatenación distributiva por la izquierda sobre la unión
			- Elemento neutro o identidad $\epsilon$
			- Relación entre \* y $\epsilon$
			- \* idempotente
- Comprobación de si una sentencia pertenece a lenguaje -> autómata finito
- Las gramáticas y lenguajes regulares tienen limitaciones a la hora de establecer conteos en partes determinadas de las expresiones. 
	- Para esto se hacen necesarias gramáticas y lenguajes independientes del contexto
### 2.3.2 Análisis sintáctico
- Sintaxis: reglas formales que especifican cómo deben formarse las sentencias de un lenguaje
- Analizador sintáctico
	- Toma los tokens recibidos del analizador léxico
	- Crea un árbol sintáctico que refleja la estructura del programa fuente
### 2.3.3 Análisis semántico
#### Gramáticas atribuidas
#### Tabla de símbolos
#### Tratamiento de errores
### 2.3.4 Generación de código intermedio
### 2.3.5 Optimización de código intermedio
### 2.3.6 Generación y optimización de código objeto
## 2.4 Traducción dirigida por la sintaxis
### 2.4.1 Definiciones dirigidas por la sintaxis
### 2.4.2 Esquemas de traducción
### 2.4.3 Métodos de análisis
#### Análisis sintáctico descendente
#### Análisis LL(1)
- Conjuntos de primeros
- Conjuntos de siguientes
- Eliminación de la ambigüedad
#### Análisis sintáctico ascendente
### Análisis SLR(1)
### 2.4.4 Herramientas para la construcción de compiladores
- Tipos
	- Generador de analizadores
	- Generadores de analizadores sintácticos
	- Generadores de analizadores léxicos
	- Generadores de árboles sintácticos
	- Generadores automáticos de código
- Destacan
	- Generadores de analizadores léxicos -> Lex
	- Generadores de analizadores sintácticos -> Yacc
- Estructura archivos Lex y Yacc
	- Sección de declaraciones
		- Símbolos terminales
		- Símbolo inicial
		- Atributos de los símbolos
		- Declaraciones de token
		- Precedencias de operadores y asociatividad
	- Sección de reglas de producción
		- Única parte obligatoria
		- Patrones
		- Reglas de producción
	- Sección de código adicional
		- Contiene el main en el lenguaje en el que se compile (con JFlex será Java, pero p. ej. con Yacc es C)
		- yyerror() manejan errores sintácticos 
		- yyparse() inicia el análisis
		- yylex() 
