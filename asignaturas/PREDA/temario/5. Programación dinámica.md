## 5.1 Planteamiento general
- Reduce el coste memorizando soluciones parciales necesarias para la resolución del problema y que se utilizan repetidamente
	- Optimización en que se cumple principio de optimalidad de Bellman
		- Toda secuencia de decisiones óptimas está basada en subsecuencias de decisiones óptimas
- Secuencia de acciones
	- Establecer ecuaciones del problema
	- Identificación de resultados parciales
	- Construcción de tabla de resultados parciales
		- Inicialización
		- Orden de llenado
		- Sustitución de llamadas recursivas por consultas a la tabla
- Ejemplo: Fibonacci
	- Algoritmo
	- Coste
## 5.2 Los coeficientes binomiales
- Coeficiente binomial
- Algoritmo iterativo
- Triángulo de Pascal
- 
## 5.3 Devolución de cambio
- Problema: hallar número mínimo de monedas necesarias para dar cantidad C
- Resolución en programación dinámica
- Algoritmo
## 5.4 El viaje por el río
- Encontrar forma más barata de ir de uno de los embarcaderos a cualquier otro río abajo
- Algoritmo
- Coste
## 5.5 La mochila (no fraccionable)
- Problema visto en voraces. Planteamiento diferente en programación dinámica.
	- Objetos indivisibles
- Algoritmo
## 5.6 Multiplicación asociativa de matrices
- Producto $M$ de $N$ matrices
- Algoritmo
- Coste
## 5.7 Camino de coste mínimo entre nodos de un grafo dirigido
- Algoritmo alternativo al de Dijkstra
- Algoritmo de Floyd
- Coste
## 5.8 Distancia de edición
- Encontrar número mínimo de cambios para transformar la cadena $X$ en la cadena $Y$
- Ecuación de recurrencia del problema
- Casos base
- Tabla $C[n, m]$
- Algoritmo
- Coste
