## 2.1 Grafos
- $G = \langle N, A \rangle$ 
	- $N$: conjunto finito de vértices o nodos
	- $A$: conjunto finito de aristas
	- $A \in N \times N$
### 2.1.1 Definiciones básicas
- Grafo dirigido
	- Aristas orientadas -> Flechas o arcos
		- $\langle n_1, n_2 \rangle$, $\langle n_2, n_1 \rangle$
		- Extremo inicial, extremo final
- Grafo no dirigido
	- Aristas no orientadas 
		- $(n_1, n_2)$
- Bucle o lazo: arista con principio y fin en el mismo nodo
- Nodos adyacentes: unidos por una arista
- Grado de un vértice: nº de aristas que entran o salen de él
	- Grado de entrada o entrante, grado de salida o saliente
- Camino
	- Longitud
	- Camino simple 
		- No utiliza más de una vez la misma arista
		- No posee bucles
	- Camino compuesto
	- Ciclo o circuito: camino que empieza y termina en el mismo vértice

### 2.1.2 Tipos de grafos
- Grafo nulo
	- Grafo sin vértices
- Grafo acíclico
	- Grafo que no contiene ciclos
- Grafo etiquetado o valorado
- Grafo simple
	- Entre cada dos vértices a lo sumo una arista
- Multigrafo
	- Más de una arista entre dos vértices
- Subgrafo
- Grafo conexo
- Grafo dirigido débilmente conexo
	- Al reemplazar aristas dirigidas por no dirigidas resulta conexo
- Grafo dirigido unilateralmente conexo (o fuertemente conexo)
	- Para cada par de vértices n y m existe un camino desde n a m o desde m a n
- Componente conexa
- Subgrafo conexo maximal
- Grafo completo
- Árbol libre
### 2.1.3 Representación de grafos
#### Matriz de adyacencia
#### Listas de adyacencia
#### Funciones de manipulación de grafos
- Funciones
	- Crear grafo
	- Añadir arista
	- Añadir vértice
	- Borrar arista
	- Borrar vértice
	- Adyacente?
	- Adyacentes
	- Etiqueta
- Costes
- Representaciones más eficientes
	- Pocas aristas -> lista de adyacencia
	- Muchas aristas -> matriz de adyacencia
### 2. 1.4 Recorrido de grafos
#### Recorrido en profundidad
- Depth-first search
- Algoritmo
	- Recursivo
	- Iterativo
- Equivalente a recorrido en preorden de un árbol
- Coste
	- Si representación mediante matriz de adyacencia, O(n²)
	- Listas de adyacencia O(n+a)
- Recorrido numerado
#### Recorrido en amplitud o anchura
- Breadth-first search
- Algoritmo
	- No es de naturaleza recursiva
	- Se usa una cola
- Coste
	- Matriz de adyacencia -> O(n²)
	- Listas de adyacencia -> O(n+a)
### 2.1.5 Árboles de recubrimiento
- Árbol asociado por recorrido en profundidad o anchura de un grafo
- Un árbol por cada recorrido que se pueda hacer del grafo
### 2.1.6 Puntos de articulación
- Dado un grafo conexo, un nodo $u$ es un punto de articulación si el grafo deja de ser conexo
- Grafo sin puntos de articulación -> biconexo
- Conectividad -> un grafo tiene conectividad $k$ si eliminar $k-1$ nodos no lo desconecta
- Algoritmo
### 2.1.7 Ordenación topológica de un grafo dirigido acíclico
- Ordenación topológica de un gda -> secuencia válida para los nodos representados. Todo gda tiene al menos una
- Algoritmo de Kahn
- Coste: O(n+a)
### 2.1.8 Camino más corto desde la raíz a cualquier otro nodo
- Recorrido en anchura
### 2.1.9 Otros algoritmos sobre grafos

## 2.2 Montículos
- Árbol binario
	- Balanceado y completo
	- Propiedad de montículo: cada nodo tiene un valor 
		- mayor al de sus hijos (montículo de máximos)
		- menor al de sus hijos (montículo de mínimos)
- Implementación usa vectores
	- $T[n]$ (padre) -> hijos: $T[2n]$, $T[2n + 1]$
- Desarrollado por Floyd, método de ordenación *Heapsort*
- Usado en algoritmos
	- ordenación (Heapsort)
	- Selección: búsqueda de mínimos, máximos, medianas, k-ésimo mayor elemento
	- Algoritmos basados en grafos: árboles de recubrimiento mínimo (Prim), problema del camino más corto (Dijkstra)
### 2.2.1 Implementación y operaciones sobre elementos del montículo
- 
### 2.2.2 Eficiencia en la creación de montículos a partir de un vector
### 2.2.3 Otros tipos de montículos
#### Montículo binomial
#### Montículo de Fibonacci
## 2.3 Tablas de dispersión (hash)
### 2.3.1 Funciones Hash
### 2.3.2 Colisiones